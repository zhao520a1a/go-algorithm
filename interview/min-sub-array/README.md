# 长度最小的子数组

* 涉及知识点：暴力求解, 二分查找, 双指针

## 题目

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。
如果不存在符合条件的子数组，返回 0。


输入/输出示例：

Example 1:

Input: 
```
s = 7, nums = [2,3,1,2,4,3]
```
Output: 
```
2
```
Explanation: 子数组 [4,3] 是该条件下的长度最小的子数组。


## 思路描述

### 思路 1 暴力求解
初始化子数组的最小长度=+∞， 两层for循环枚举数组内数据，外层遍历每个点i，内层计算每个点i到向后的j，使得从 nums[i]到nums[j] 的元素和大于或等于 ss，并更新子数组的最小长度（此时子数组的长度是 j-i+1j−i+1）
                                      

* 时间复杂度：O(n2)
* 空间复杂度：o(1)
**提出思路1分，能正确分析时空复杂度+1**


### 思路 2 前缀和+二分查找
需要额外创建一个数组 sums 用于存储数组 nums 的前缀和，其中 sums[i] 表示从 nums[0] 到 nums[i−1] 的元素和。
得到前缀和之后，对于每个开始下标 ii，可通过二分查找得到大于或等于 ii 的最小下标 bound，
使得 sums[bound]-sums[i-1] >= s，并更新子数组的最小长度（此时子数组的长度是 bound−(i−1)）。

因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性。
如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。
                                
* 时间复杂度：O(n log n)
* 空间复杂度：o(n)

**提出思路3分，能正确分析时空复杂度+1**

### 思路 3 双指针
定义两个指针 start 和 end 分别表示子数组的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）。
初始状态下，start 和 end 都指向下标 0，sum 的值为 0。
每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），
然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum < s，在此过程中同样更新子数组的最小长度。
在每一轮迭代的最后，将 end 右移。
                                   

* 时间复杂度：O(n)
* 空间复杂度：o(1)

**提出思路3分，能正确分析时空复杂度+1**

## 参考代码:

[思路1](./min-sub-array/violence.go)
[思路2](./min-sub-array/binary.go)
[思路3](./min-sub-array/dualdptr.go)



