> 知识点： 异或位运算

## 找出数组中单独除出现的一个数字

### 题目描述
一组数据中只有一个数字出现了一次，其他所有数字都是成对出现的，请找出这个数字。 

#### 示例 1：
``` 
示例 1：
输入：arr = [ 1, 2, 2, 5, 1]
输出：5

示例 1：
输入：arr = [ 1, 2, 2, 5, 1]
输出：5

```
#### 限制：
要求时间复杂度O(1)

### 解法
- 思考1： 直接比较法（比较笨），每一个数都和其余的数比较，直到找出单独的,但时间复杂度 O(n^2)  // 不符合题干要求。
- 思考2： 题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现依次的数字，因为那些出现两次的数字全部在异或中抵消掉了。

##### 算法流程：
把数组中所有元素都异或一遍，最后得到的结果就是那个单独出现的数字。
 
##### 复杂度分析：
- 时间复杂度 O(1) ： 遍历数组使用 O(n) ，每轮遍历的判断和交换操作使用 O(1) 。
``` go
// 异或位运算
 func findAloneNum(arr []int) int {
 	num := 0
 	for _, item := range arr {
 		num ^= item
 	}
 	return num
 }
```

### 题目来源
 
 
 

## 找出数组中单独除出现的两个数字

### 题目描述
一个数组中只有两个数字单独出现，其余数字都是成对出现的，请找出这两个数，要求从小到大输出结果。

#### 示例 1：
``` 
示例 1：
输入：arr = [ 1, 4, 2, 5, 1, 2]
输出：4, 5

```
#### 限制：

#### 解法
如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其他数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。

##### 算法流程：
从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0，也就是说在这个结果数字的二进制表示中至少就有一位为1。我们在结果数字中找到第一个为1的位的位置，记为第N位。现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N位都为1，而第二个子数组的每个数字的第N位都为0。
现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。因此到此为止，所有的问题我们都已经解决。

##### 复杂度分析：
- 时间复杂度 O(n)

``` go
func findAloneTwoNum(arr []int) (num1 int, num2 int) {
	ret := findAloneNum(arr)
	var i uint
	// //先找到一位为1的bit位
	for i = 0; i < 32; i++ {
		if ((ret >> i) & 1) == 1 {
			break
		}
	}

	// //按照这一位将数组分成两部分分别异或
	for _, item := range arr {
		if (item>>i)&1 == 0 {
			num1 ^= item
		} else {
			num2 ^= item
		}
	}

	return
}

```

#### 题目来源
https://www.cnblogs.com/youxin/p/3349834.html
https://blog.csdn.net/sinat_34967445/article/details/76752550